local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local Lighting = game:GetService("Lighting")
local effect = Lighting:FindFirstChild("VibrantEffect")
local vibrantEffect = Lighting:FindFirstChild("VibrantEffect")
local RunService = game:GetService("RunService")

Lighting.ClockTime = 14
Lighting.GlobalShadows = false

WindUI:AddTheme({
    Name = "Dark",
    Accent = "#18181b",
    Dialog = "#18181b", 
    Outline = "#FFFFFF",
    Text = "#FFFFFF",
    Placeholder = "#999999",
    Background = "#0e0e10",
    Button = "#52525b",
    Icon = "#a1a1aa",
})

WindUI:AddTheme({
    Name = "Light",
    Accent = "#f4f4f5",
    Dialog = "#f4f4f5",
    Outline = "#000000", 
    Text = "#000000",
    Placeholder = "#666666",
    Background = "#ffffff",
    Button = "#e4e4e7",
    Icon = "#52525b",
})

WindUI:AddTheme({
    Name = "Gray",
    Accent = "#374151",
    Dialog = "#374151",
    Outline = "#d1d5db", 
    Text = "#f9fafb",
    Placeholder = "#9ca3af",
    Background = "#1f2937",
    Button = "#4b5563",
    Icon = "#d1d5db",
})

WindUI:AddTheme({
    Name = "Blue",
    Accent = "#1e40af",
    Dialog = "#1e3a8a",
    Outline = "#93c5fd", 
    Text = "#f0f9ff",
    Placeholder = "#60a5fa",
    Background = "#1e293b",
    Button = "#3b82f6",
    Icon = "#93c5fd",
})

WindUI:AddTheme({
    Name = "Green",
    Accent = "#059669",
    Dialog = "#047857",
    Outline = "#6ee7b7", 
    Text = "#ecfdf5",
    Placeholder = "#34d399",
    Background = "#064e3b",
    Button = "#10b981",
    Icon = "#6ee7b7",
})

WindUI:AddTheme({
    Name = "Purple",
    Accent = "#7c3aed",
    Dialog = "#6d28d9",
    Outline = "#c4b5fd", 
    Text = "#faf5ff",
    Placeholder = "#a78bfa",
    Background = "#581c87",
    Button = "#8b5cf6",
    Icon = "#c4b5fd",
})

WindUI:SetNotificationLower(true)

local themes = {"Dark", "Light", "Gray", "Blue", "Green", "Purple"}
local currentThemeIndex = 1

if not getgenv().TransparencyEnabled then
    getgenv().TransparencyEnabled = true
end

-- combat

local scan_map = false
-- esp

local ie = {
    "Bandage", "Bolt", "Broken Fan", "Broken Microwave", "Cake", "Carrot", "Chair", "Coal", "Coin Stack",
    "Cooked Morsel", "Cooked Steak", "Fuel Canister", "Iron Body", "Leather Armor", "Log", "MadKit", "Metal Chair",
    "MedKit", "Old Car Engine", "Old Flashlight", "Old Radio", "Revolver", "Revolver Ammo", "Rifle", "Rifle Ammo",
    "Morsel", "Sheet Metal", "Steak", "Tyre", "Washing Machine", "Cultist Gem", "Gem of the Forest Fragment"
}
local me = {"Bunny", "Wolf", "Alpha Wolf", "Bear", "Cultist", "Crossbow Cultist", "Alien", "Alien Elite"}

-- bring

local junkItems = {"Tyre", "Bolt", "Broken Fan", "Broken Microwave", "Sheet Metal", "Old Radio", "Washing Machine", "Old Car Engine"}
local selectedJunkItems = {}
local fuelItems = {"Log", "Chair", "Coal", "Fuel Canister", "Oil Barrel"}
local selectedFuelItems = {}
local foodItems = {"Cake", "Cooked Steak", "Cooked Morsel", "Ribs", "Salmon", "Cooked Salmon", "Cooked Ribs", "Mackerel", "Cooked Mackerel", "Steak", "Morsel", "Berry", "Carrot"}
local selectedFoodItems = {}
local medicalItems = {"Bandage", "MedKit"}
local selectedMedicalItems = {}
local equipmentItems = {"Revolver", "Rifle", "Old Flashlight", "Leather Body", "Iron Body", "Revolver Ammo", "Rifle Ammo", "Giant Sack", "Good Sack", "Strong Axe", "Good Axe"}
local selectedEquipmentItems = {}

local isCollecting = false
local originalPosition = nil
local autoBringEnabled = false

-- Toggle states for each category
local junkToggleEnabled = false
local fuelToggleEnabled = false
local foodToggleEnabled = false
local medicalToggleEnabled = false
local equipmentToggleEnabled = false

-- Loop control variables to properly stop threads
local junkLoopRunning = false
local fuelLoopRunning = false
local foodLoopRunning = false
local medicalLoopRunning = false
local equipmentLoopRunning = false

-- Enhanced smooth pulling movement with easing
local function smoothPullToItem(startPos, endPos, duration)
    local player = game.Players.LocalPlayer
    local hrp = player.Character.HumanoidRootPart
    
    local startTime = tick()
    local distance = (endPos.Position - startPos.Position).Magnitude
    local direction = (endPos.Position - startPos.Position).Unit
    
    -- Create smooth pulling effect with easing
    spawn(function()
        while tick() - startTime < duration do
            local elapsed = tick() - startTime
            local progress = elapsed / duration
            
            -- Ease-in-out function for smooth acceleration and deceleration
            local easedProgress = progress < 0.5 
                and 2 * progress * progress 
                or 1 - math.pow(-2 * progress + 2, 2) / 2
            
            local currentPos = startPos.Position:lerp(endPos.Position, easedProgress)
            local lookDirection = endPos.Position - currentPos
            
            if lookDirection.Magnitude > 0 then
                hrp.CFrame = CFrame.lookAt(currentPos, currentPos + lookDirection.Unit)
            else
                hrp.CFrame = CFrame.new(currentPos)
            end
            
            wait()
        end
        
        -- Ensure exact final position
        hrp.CFrame = endPos
    end)
    
    wait(duration)
end

-- Enhanced item pulling effect
local function createItemPullEffect(itemPart, targetPos, duration)
    if not itemPart or not itemPart.Parent then return end
    
    local startPos = itemPart.Position
    local startTime = tick()
    
    spawn(function()
        while tick() - startTime < duration do
            if not itemPart or not itemPart.Parent then break end
            
            local elapsed = tick() - startTime
            local progress = elapsed / duration
            
            -- Ease-out effect for item pulling
            local easedProgress = 1 - math.pow(1 - progress, 3)
            
            local currentPos = Vector3.new(
                startPos.X + (targetPos.X - startPos.X) * easedProgress,
                startPos.Y + (targetPos.Y - startPos.Y) * easedProgress,
                startPos.Z + (targetPos.Z - startPos.Z) * easedProgress
            )
            
            pcall(function()
                itemPart.CFrame = CFrame.new(currentPos)
                itemPart.Velocity = Vector3.new(0, 0, 0)
                itemPart.AngularVelocity = Vector3.new(0, 0, 0)
            end)
            
            wait()
        end
        
        -- Final position
        pcall(function()
            itemPart.CFrame = CFrame.new(targetPos)
            itemPart.Velocity = Vector3.new(0, 0, 0)
            itemPart.AngularVelocity = Vector3.new(0, 0, 0)
        end)
    end)
    
    wait(duration)
end

-- Enhanced bypass system with smooth pulling (no noclip)
local function bypassBringSystem(items, stopFlag)
    if isCollecting then 
        return 
    end
    
    isCollecting = true
    local player = game.Players.LocalPlayer
    
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then 
        isCollecting = false
        return 
    end
    
    local hrp = player.Character.HumanoidRootPart
    originalPosition = hrp.CFrame
    
    for _, itemName in ipairs(items) do
        -- Check if we should stop
        if stopFlag and not stopFlag() then
            break
        end
        
        local itemsFound = {}
        
        -- Find all items with this name
        for _, item in ipairs(workspace:GetDescendants()) do
            if item.Name == itemName and (item:IsA("BasePart") or item:IsA("Model")) then
                local itemPart = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")) or item
                if itemPart and itemPart.Parent ~= player.Character then
                    table.insert(itemsFound, {item = item, part = itemPart})
                end
            end
        end
        
        -- Process each found item
        for _, itemData in ipairs(itemsFound) do
            -- Check if we should stop again
            if stopFlag and not stopFlag() then
                break
            end
            
            local item = itemData.item
            local itemPart = itemData.part
            
            if itemPart and itemPart.Parent then
                -- Step 1: Smooth pull to item location with anticipation
                local itemPos = itemPart.CFrame + Vector3.new(0, 5, 0)
                smoothPullToItem(hrp.CFrame, itemPos, 1.2) -- Smooth 1.2 second pull
                
                -- Step 2: Create magnetic pull effect for item
                local playerPos = hrp.Position + Vector3.new(0, -1, 0)
                createItemPullEffect(itemPart, playerPos, 0.8)
                
                -- Step 3: Smooth return journey with item following
                local keepAttached = true
                spawn(function()
                    while keepAttached do
                        if stopFlag and not stopFlag() then
                            keepAttached = false
                            break
                        end
                        
                        if itemPart and itemPart.Parent and hrp and hrp.Parent then
                            pcall(function()
                                local offset = Vector3.new(
                                    math.sin(tick() * 2) * 0.5, -- Slight floating motion
                                    -1 + math.cos(tick() * 3) * 0.2,
                                    math.cos(tick() * 2) * 0.5
                                )
                                itemPart.CFrame = CFrame.new(hrp.Position + offset)
                                itemPart.Velocity = Vector3.new(0, 0, 0)
                                itemPart.AngularVelocity = Vector3.new(0, 0, 0)
                            end)
                        end
                        wait(0.03)
                    end
                end)
                
                -- Smooth return to original position
                smoothPullToItem(hrp.CFrame, originalPosition, 1.0)
                
                -- Stop attachment and place item nearby with gentle landing
                keepAttached = false
                wait(0.1)
                
                pcall(function()
                    local landingPos = originalPosition.Position + Vector3.new(
                        math.random(-4, 4), 
                        2, 
                        math.random(-4, 4)
                    )
                    
                    -- Gentle item placement
                    createItemPullEffect(itemPart, landingPos, 0.5)
                end)
            end
            
            wait(0.5) -- Pause between items
        end
    end
    
    -- Ensure player is at original position
    if originalPosition then
        hrp.CFrame = originalPosition
    end
    
    isCollecting = false
end

-- auto upgrade campfire

local campfireFuelItems = {"Log", "Coal", "Chair", "Fuel Canister", "Oil Barrel", "Biofuel"}
local campfireDropPos = Vector3.new(0, 19, 0)
local selectedCampfireItem = nil -- Single item storage
local autoUpgradeCampfireEnabled = false

-- Added New
local scrapjunkItems = {"Log", "Chair", "Tyre", "Bolt", "Broken Fan", "Broken Microwave", "Sheet Metal", "Old Radio", "Washing Machine", "Old Car Engine"}
local autoScrapPos = Vector3.new(21, 20, -5)
local selectedScrapItem = nil
local autoScrapItemsEnabled = false
-- auto cook

local autocookItems = {"Morsel", "Steak", "Ribs", "Salmon", "Mackerel"}
local autoCookEnabledItems = {}
local autoCookEnabled = false


function wiki(nome)
    local c = 0
    for _, i in ipairs(Workspace.Items:GetChildren()) do
        if i.Name == nome then
            c = c + 1
        end
    end
    return c
end

function ghn()
    return math.floor(LocalPlayer.PlayerGui.Interface.StatBars.HungerBar.Bar.Size.X.Scale * 100)
end

function feed(nome)
    for _, item in ipairs(Workspace.Items:GetChildren()) do
        if item.Name == nome then
            ReplicatedStorage.RemoteEvents.RequestConsumeItem:InvokeServer(item)
            break
        end
    end
end

function notifeed(nome)
    WindUI:Notify({
        Title = "Auto Food Paused",
        Content = "The food is gone",
        Duration = 3
    })
end

local function moveItemToPos(item, position)
    if not item or not item:IsDescendantOf(workspace) or not item:IsA("BasePart") and not item:IsA("Model") then return end
    local part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart") or item:FindFirstChild("Handle")) or item
    if not part or not part:IsA("BasePart") then return end

    if item:IsA("Model") and not item.PrimaryPart then
        pcall(function() item.PrimaryPart = part end)
    end

    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents").RequestStartDraggingItem:FireServer(item)
        if item:IsA("Model") then
            item:SetPrimaryPartCFrame(CFrame.new(position))
        else
            part.CFrame = CFrame.new(position)
        end
        game:GetService("ReplicatedStorage"):WaitForChild("RemoteEvents").StopDraggingItem:FireServer(item)
    end)
end

local function getChests()
    local chests = {}
    local chestNames = {}
    local index = 1
    for _, item in ipairs(workspace:WaitForChild("Items"):GetChildren()) do
        if item.Name:match("^Item Chest") and not item:GetAttribute("8721081708ed") then
            table.insert(chests, item)
            table.insert(chestNames, "Chest " .. index)
            index = index + 1
        end
    end
    return chests, chestNames
end

local currentChests, currentChestNames = getChests()
local selectedChest = currentChestNames[1] or nil

local function getMobs()
    local mobs = {}
    local mobNames = {}
    local index = 1
    for _, character in ipairs(workspace:WaitForChild("Characters"):GetChildren()) do
        if character.Name:match("^Lost Child") and character:GetAttribute("Lost") == true then
            table.insert(mobs, character)
            table.insert(mobNames, character.Name)
            index = index + 1
        end
    end
    return mobs, mobNames
end

local currentMobs, currentMobNames = getMobs()
local selectedMob = currentMobNames[1] or nil

function tp1()
	(game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()):WaitForChild("HumanoidRootPart").CFrame =
CFrame.new(0.43132782, 15.77634621, -1.88620758, -0.270917892, 0.102997094, 0.957076371, 0.639657021, 0.762253821, 0.0990355015, -0.719334781, 0.639031112, -0.272391081)
end

local function tp2()
    local targetPart = workspace:FindFirstChild("Map")
        and workspace.Map:FindFirstChild("Landmarks")
        and workspace.Map.Landmarks:FindFirstChild("Stronghold")
        and workspace.Map.Landmarks.Stronghold:FindFirstChild("Functional")
        and workspace.Map.Landmarks.Stronghold.Functional:FindFirstChild("EntryDoors")
        and workspace.Map.Landmarks.Stronghold.Functional.EntryDoors:FindFirstChild("DoorRight")
        and workspace.Map.Landmarks.Stronghold.Functional.EntryDoors.DoorRight:FindFirstChild("Model")
    if targetPart then
        local children = targetPart:GetChildren()
        local destination = children[5]
        if destination and destination:IsA("BasePart") then
            local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.CFrame = destination.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
end

local flyToggle = false
local flySpeed = 1
local FLYING = false
local flyKeyDown, flyKeyUp, mfly1, mfly2
local IYMouse = game:GetService("UserInputService")

-- Fly pc
local function sFLY()
    repeat task.wait() until Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart") and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat task.wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect(); flyKeyUp:Disconnect() end

    local T = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = flySpeed

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.CFrame = T.CFrame
        BV.Velocity = Vector3.new(0, 0, 0)
        BV.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            while FLYING do
                task.wait()
                if not flyToggle and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = flySpeed
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.Velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.Velocity = Vector3.new(0, 0, 0)
                end
                BG.CFrame = workspace.CurrentCamera.CoordinateFrame
            end
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local KEY = input.KeyCode.Name
            if KEY == "W" then
                CONTROL.F = flySpeed
            elseif KEY == "S" then
                CONTROL.B = -flySpeed
            elseif KEY == "A" then
                CONTROL.L = -flySpeed
            elseif KEY == "D" then 
                CONTROL.R = flySpeed
            elseif KEY == "E" then
                CONTROL.Q = flySpeed * 2
            elseif KEY == "Q" then
                CONTROL.E = -flySpeed * 2
            end
            pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
        end
    end)
    flyKeyUp = IYMouse.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Keyboard then
            local KEY = input.KeyCode.Name
            if KEY == "W" then
                CONTROL.F = 0
            elseif KEY == "S" then
                CONTROL.B = 0
            elseif KEY == "A" then
                CONTROL.L = 0
            elseif KEY == "D" then
                CONTROL.R = 0
            elseif KEY == "E" then
                CONTROL.Q = 0
            elseif KEY == "Q" then
                CONTROL.E = 0
            end
        end
    end)
    FLY()
end

-- Fly mobile
local function NOFLY()
    FLYING = false
    if flyKeyDown then flyKeyDown:Disconnect() end
    if flyKeyUp then flyKeyUp:Disconnect() end
    if mfly1 then mfly1:Disconnect() end
    if mfly2 then mfly2:Disconnect() end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

local function UnMobileFly()
    pcall(function()
        FLYING = false
        local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        if root:FindFirstChild("BodyVelocity") then root:FindFirstChild("BodyVelocity"):Destroy() end
        if root:FindFirstChild("BodyGyro") then root:FindFirstChild("BodyGyro"):Destroy() end
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
            Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        end
        if mfly1 then mfly1:Disconnect() end
        if mfly2 then mfly2:Disconnect() end
    end)
end

local function MobileFly()
    UnMobileFly()
    FLYING = true

    local root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = "BodyVelocity"
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = "BodyGyro"
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = Players.LocalPlayer.CharacterAdded:Connect(function()
        local newRoot = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        local newBv = Instance.new("BodyVelocity")
        newBv.Name = "BodyVelocity"
        newBv.Parent = newRoot
        newBv.MaxForce = v3zero
        newBv.Velocity = v3zero

        local newBg = Instance.new("BodyGyro")
        newBg.Name = "BodyGyro"
        newBg.Parent = newRoot
        newBg.MaxTorque = v3inf
        newBg.P = 1000
        newBg.D = 50
    end)

    mfly2 = game:GetService("RunService").RenderStepped:Connect(function()
        root = Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        camera = workspace.CurrentCamera
        if Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild("BodyVelocity") and root:FindFirstChild("BodyGyro") then
            local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild("BodyVelocity")
            local GyroHandler = root:FindFirstChild("BodyGyro")

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            humanoid.PlatformStand = true
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * (flySpeed * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * (flySpeed * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * (flySpeed * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * (flySpeed * 50))
            end
        end
    end)
end

-- Player TP to Items Bring System
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Function to teleport player to item, pick it up, then return with item
local function bringItemsByPlayerTP(itemNames, originalPosition)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
        return 
    end
    
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local itemsFound = {}
    
    -- Collect all matching items first
    for _, itemName in ipairs(itemNames) do
        for _, item in ipairs(workspace:GetDescendants()) do
            if item.Name == itemName and (item:IsA("BasePart") or item:IsA("Model")) then
                local part = item:IsA("Model") and (item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")) or item
                if part and part:IsA("BasePart") then
                    table.insert(itemsFound, {item = item, part = part})
                end
            end
        end
    end
    
    -- Process each item
    for i, itemData in ipairs(itemsFound) do
        local item = itemData.item
        local part = itemData.part
        
        -- Check if item still exists
        if item and item.Parent and part then
            -- Step 1: Teleport player to the item
            local itemPosition = part.Position + Vector3.new(0, 3, 0) -- Slightly above item
            hrp.CFrame = CFrame.new(itemPosition)
            
            task.wait(0.2) -- Wait a moment for teleport to register
            
            -- Step 2: Start dragging the item (this attaches it to player)
            pcall(function()
                ReplicatedStorage:WaitForChild("RemoteEvents").RequestStartDraggingItem:FireServer(item)
            end)
            
            task.wait(0.3) -- Wait for item to attach
            
            -- Step 3: Teleport back to original position with the item
            hrp.CFrame = CFrame.new(originalPosition)
            
            task.wait(0.2) -- Wait for teleport
            
            -- Step 4: Stop dragging to drop the item at original position
            pcall(function()
                ReplicatedStorage:WaitForChild("RemoteEvents").StopDraggingItem:FireServer(item)
            end)
            
            task.wait(0.5) -- Wait between items to avoid spam detection
        end
    end
    
    -- Final teleport back to original position
    hrp.CFrame = CFrame.new(originalPosition)
end

local Window = WindUI:CreateWindow({
    Title = "Dual Hub",
    Icon = "rbxassetid://115670808395939", 
    Author = "99 Night in the Forest",
    Folder = "Dual Hub",
    Size = UDim2.fromOffset(500, 350),
    Transparent = getgenv().TransparencyEnabled,
    Theme = "Purple",
    Resizable = true,
    SideBarWidth = 150,
    BackgroundImageTransparency = 0.8,
    HideSearchBar = false,
    ScrollBarEnabled = true,

    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function()
            currentThemeIndex = currentThemeIndex + 1
            if currentThemeIndex > #themes then
                currentThemeIndex = 1
            end
            
            local newTheme = themes[currentThemeIndex]
            WindUI:SetTheme(newTheme)
           
            WindUI:Notify({
                Title = "Theme Changed",
                Content = "Switched to " .. newTheme .. " theme!",
                Duration = 2,
                Icon = "palette"
            })
            print("Switched to " .. newTheme .. " theme")
        end,
    },
})

Window:Tag({
    Title = "v2.2.1 [BETA]",
    Color = Color3.fromHex("#30ff6a")
})


Window:SetToggleKey(Enum.KeyCode.T)
Window:EditOpenButton({
    Title = "Dual Hub",
    Icon = "star",
    CornerRadius = UDim.new(0,0),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("8B4513"),
        Color3.fromHex("FFFFFF")
    ),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})


pcall(function()
    Window:CreateTopbarButton("TransparencyToggle", "eye", function()
        if getgenv().TransparencyEnabled then
            getgenv().TransparencyEnabled = false
            pcall(function() Window:ToggleTransparency(false) end)
            
            WindUI:Notify({
                Title = "Transparency", 
                Content = "Transparency disabled",
                Duration = 3,
                Icon = "eye"
            })
            print("Transparency = false")
        else
            getgenv().TransparencyEnabled = true
            pcall(function() Window:ToggleTransparency(true) end)
            
            WindUI:Notify({
                Title = "Transparency",
                Content = "Transparency enabled", 
                Duration = 3,
                Icon = "eye-off"
            })
            print(" Transparency = true")
        end
        
        -- Debug: Print current state
        print("Debug - Current Transparency state:", getgenv().TransparencyEnabled)
    end, 990)
end)

Window:EditOpenButton({
    Title = "Dual Hub",
    Icon = "monitor",
    CornerRadius = UDim.new(0, 6),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromRGB(30, 30, 30), Color3.fromRGB(255, 255, 255)),
    Draggable = true,
})

local Tabs = {}

Tabs.Info = Window:Tab({
    Title = "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•",
    Icon = "badge-info",
    Desc = "Dual"
})
Tabs.Auto = Window:Tab({
    Title = "‡∏´‡∏•‡∏±‡∏Å",
    Icon = "rocket",
    Desc = "Dual"
})
Tabs.br = Window:Tab({
    Title = "‡∏î‡∏∂‡∏á‡∏Ç‡∏≠‡∏á",
    Icon = "package",
    Desc = "Dual"
})
Tabs.Fly = Window:Tab({
    Title = "‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô",
    Icon = "user",
    Desc = "Dual"
})
Tabs.esp = Window:Tab({
    Title = "Esp",
    Icon = "eye",
    Desc = "Dual"
})
Tabs.Tp = Window:Tab({
    Title = "‡∏ß‡∏≤‡∏õ",
    Icon = "map",
    Desc = "Dual"
})

Tabs.Anti = Window:Tab({
    Title = "‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô",
    Icon = "shield",
    Desc = "Dual"
})

Tabs.Vision = Window:Tab({
    Title = "‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤",
    Icon = "settings",
    Desc = "Dual"
})

Window:SelectTab(1)

-- ==============================
-- üî• ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
-- ==============================
Tabs.Auto:Section({ Title = "‡∏™‡πÅ‡∏Å‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà", Icon = "map" })

Tabs.Auto:Toggle({
    Title = "‡∏™‡πÅ‡∏Å‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏¥‡∏î [‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô]",
    Default = false,
    Callback = function(state)
        scan_map = state

        if not state then
            scan_map_was_on = false
            return
        else
            scan_map_was_on = true
        end

        task.spawn(function()
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:WaitForChild("HumanoidRootPart", 3)
            if not hrp then return end

            -- ‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°
            if type(tp1) == "function" then
                tp1()
            end

            local center = hrp.Position + Vector3.new(0,20,0) -- ‡∏•‡∏≠‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô 20 studs
            local radius = 5 -- ‡πÄ‡∏£‡∏¥‡πà‡∏° radius
            local maxRadius = 1400
            local radialSpeed = 500 -- studs per second (‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏∏‡∏î)
            local angularSpeed = math.rad(2000) -- rad/s (‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏∏‡∏î)
            local dt = 0.005 -- time step ‡πÄ‡∏•‡πá‡∏Å‡∏°‡∏≤‡∏Å

            while scan_map and radius <= maxRadius do
                local angle = 0
                while scan_map and angle < 2*math.pi do
                    local x = math.cos(angle) * radius
                    local z = math.sin(angle) * radius
                    local targetPos = center + Vector3.new(x, 0, z)
                    hrp.CFrame = CFrame.new(targetPos)

                    -- ‡∏ß‡∏≤‡∏á Foot Part ‡πÇ‡∏õ‡∏£‡πà‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏±‡∏á‡πÄ‡∏Å‡∏ï
                    local footPart = Instance.new("Part")
                    footPart.Size = Vector3.new(2,1,2)
                    footPart.Anchored = true
                    footPart.CanCollide = true
                    footPart.Transparency = 1
                    footPart.BrickColor = BrickColor.new("Bright yellow")
                    footPart.CFrame = CFrame.new(targetPos - Vector3.new(0,3,0))
                    footPart.Parent = workspace
                    game.Debris:AddItem(footPart, 1)

                    angle = angle + angularSpeed * dt
                    task.wait(dt)
                end

                -- ‡∏Ç‡∏¢‡∏≤‡∏¢ radius ‡∏ï‡∏≤‡∏° speed ‡∏Ñ‡∏á‡∏ó‡∏µ‡πà
                radius = radius + radialSpeed * dt
            end

            -- ‡∏ß‡∏≤‡∏õ‡∏Å‡∏•‡∏±‡∏ö‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡πÄ‡∏°‡∏∑‡πà‡∏≠ spiral ‡∏ñ‡∏∂‡∏á 1400Stud
            if type(tp1) == "function" then
                tp1()
            end

            scan_map = false
            scan_map_was_on = false
        end)
    end
})








-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ Toggle ‡πÅ‡∏•‡∏∞ Config
local choppingTasks = {}
local killAuraToggle = false
local chopAuraToggle = false
local currentammount = 0
local autoChopToggle = false
local auraRadius = 70 -- ‡∏£‡∏∞‡∏¢‡∏∞‡∏ï‡∏±‡∏î‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß


local toolsDamageIDs = {
    ["Old Axe"] = "3_7367831688",
    ["Good Axe"] = "112_7367831688",
    ["Strong Axe"] = "116_7367831688",
    ["Chainsaw"] = "647_8992824875",
    ["Infernal Sword"] = "2_4340578793",
    ["Spear"] = "196_8999010016"
}

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Tool
local function getAnyToolWithDamageID(isChopAura)
    for toolName, damageID in pairs(toolsDamageIDs) do
        if isChopAura then
            if toolName ~= "Old Axe" and toolName ~= "Good Axe" and toolName ~= "Strong Axe" then
                -- ‡∏Ç‡πâ‡∏≤‡∏°‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ
            else
                local tool = LocalPlayer:FindFirstChild("Inventory") and LocalPlayer.Inventory:FindFirstChild(toolName)
                if tool then
                    return tool, damageID
                end
            end
        else
            local tool = LocalPlayer:FindFirstChild("Inventory") and LocalPlayer.Inventory:FindFirstChild(toolName)
            if tool then
                return tool, damageID
            end
        end
    end
    return nil, nil
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏™‡πà‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò
local function equipTool(tool)
    if tool then
        ReplicatedStorage:WaitForChild("RemoteEvents").EquipItemHandle:FireServer("FireAllClients", tool)
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ñ‡∏≠‡∏î‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò
local function unequipTool(tool)
    if tool then
        ReplicatedStorage:WaitForChild("RemoteEvents").UnequipItemHandle:FireServer("FireAllClients", tool)
    end
end

-- Loop ‡∏Ü‡πà‡∏≤‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå
local function killAuraLoop()
    while killAuraToggle do
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local tool, damageID = getAnyToolWithDamageID(false)
            if tool and damageID then
                equipTool(tool)
                for _, mob in ipairs(Workspace.Characters:GetChildren()) do
                    if mob:IsA("Model") then
                        local part = mob:FindFirstChildWhichIsA("BasePart")
                        if part and (part.Position - hrp.Position).Magnitude <= auraRadius then
                            pcall(function()
                                ReplicatedStorage:WaitForChild("RemoteEvents").ToolDamageObject:InvokeServer(
                                    mob,
                                    tool,
                                    damageID,
                                    CFrame.new(part.Position)
                                )
                            end)
                        end
                    end
                end
                task.wait(0.1)
            else
                task.wait(1)
            end
        else
            task.wait(0.5)
        end
    end
end
-- ===========================================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Highlight ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡∏î
-- ===========================================
local function createTreeHighlight(tree)
    if not tree or not tree.Parent then return nil end
    local trunk = tree:FindFirstChild("Trunk")
    if not trunk or not trunk:IsA("BasePart") then return nil end

    local existingHighlight = trunk:FindFirstChild("TreeHighlight")
    if existingHighlight then
        return existingHighlight
    end

    local highlight = Instance.new("Highlight")
    highlight.Name = "TreeHighlight"
    highlight.Adornee = trunk
    highlight.FillColor = Color3.fromRGB(255, 0, 0) -- ‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏™‡∏î
    highlight.FillTransparency = 0.2
    highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
    highlight.OutlineTransparency = 0
    highlight.Parent = trunk
    return highlight
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï ESP / Highlight
local function updateTreeESP(tree, isCutting)
    if not tree or not tree.Parent then return end
    local trunk = tree:FindFirstChild("Trunk")
    if not trunk or not trunk:IsA("BasePart") then return end

    if isCutting then
        createTreeHighlight(tree) -- Highlight ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô‡∏ï‡∏±‡∏î
    else
        local existingHighlight = trunk:FindFirstChild("TreeHighlight")
        if existingHighlight then
            existingHighlight:Destroy()
        end
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏ö Highlight ‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function removeAllTreeHighlights()
    local map = Workspace:FindFirstChild("Map")
    if not map then return end

    local function destroyHighlights(parent)
        for _, obj in ipairs(parent:GetChildren()) do
            if obj:IsA("Model") then
                local trunk = obj:FindFirstChild("Trunk")
                if trunk and trunk:IsA("BasePart") then
                    local hl = trunk:FindFirstChild("TreeHighlight")
                    if hl then hl:Destroy() end
                end
            end
        end
    end

    if map:FindFirstChild("Foliage") then destroyHighlights(map.Foliage) end
    if map:FindFirstChild("Landmarks") then destroyHighlights(map.Landmarks) end
end

-- ===========================================
-- Chop Aura Loop
-- ===========================================
local function chopAuraLoop()
    while chopAuraToggle do
        local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then task.wait(0.1) continue end

        local tool, baseDamageID = getAnyToolWithDamageID(true)
        if not (tool and baseDamageID) then task.wait(0.1) continue end
        equipTool(tool)
        currentammount = currentammount + 1

        local map = Workspace:FindFirstChild("Map")
        if not map then task.wait(0.1) continue end

        local trees = {}

        -- ‡πÄ‡∏Å‡πá‡∏ö‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        local function collectTrees(parent)
            for _, obj in ipairs(parent:GetChildren()) do
                if obj:IsA("Model") then
                    local name = obj.Name
                    if name == "Small Tree" or name == "Snowy Small Tree" or name == "Small Webbed Tree" or name == "Wet Tree" or name == "TreeBig" then
                        table.insert(trees, obj)
                    end
                end
            end
        end

        if map:FindFirstChild("Foliage") then collectTrees(map.Foliage) end
        if map:FindFirstChild("Landmarks") then collectTrees(map.Landmarks) end

        for _, tree in ipairs(trees) do
            local trunk = tree:FindFirstChild("Trunk")
            if trunk then
                local isCutting = (trunk.Position - hrp.Position).Magnitude <= auraRadius

                -- ‡∏™‡∏£‡πâ‡∏≤‡∏á Highlight ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏±‡∏î
                updateTreeESP(tree, isCutting)

                -- ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å task ‡πÄ‡∏î‡∏¥‡∏°
                if choppingTasks[tree] then
                    task.cancel(choppingTasks[tree])
                    choppingTasks[tree] = nil
                end

                if isCutting then
                    choppingTasks[tree] = task.spawn(function()
                        while chopAuraToggle and tree and tree.Parent do
                            currentammount = currentammount + 1
                            pcall(function()
                                ReplicatedStorage:WaitForChild("RemoteEvents").ToolDamageObject:InvokeServer(
                                    tree,
                                    tool,
                                    tostring(currentammount) .. "_7367831688",
                                    CFrame.new(-2.962610244751, 4.5547881126404, -75.950843811035)
                                )
                            end)
                            task.wait(0.5)
                        end
                    end)
                end
            end
        end

        task.wait(0.1)
    end
end

local function collectTrees()
    local trees = {}
    local map = Workspace:FindFirstChild("Map")
    if not map then return trees end

    local function addTrees(parent)
        for _, obj in ipairs(parent:GetChildren()) do
            if obj:IsA("Model") then
                local name = obj.Name
                if name == "Small Tree" or name == "Snowy Small Tree" or name == "Small Webbed Tree" or name == "Wet Tree" or name == "TreeBig" then
                    table.insert(trees, obj)
                end
            end
        end
    end

    if map:FindFirstChild("Foliage") then addTrees(map.Foliage) end
    if map:FindFirstChild("Landmarks") then addTrees(map.Landmarks) end

    return trees
end


-- ===========================================
-- Auto Chop Warp (‡∏á‡πà‡∏≤‡∏¢)
-- ===========================================
local function warpcop()
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart", 3)
    if not hrp then return end

    while autoChopToggle do
        local trees = collectTrees()
        if #trees == 0 then
            task.wait(1)
            continue
        end

        local nearestTree = nil
        local nearestDist = math.huge

        -- ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞ 70
        for _, tree in ipairs(trees) do
            local trunk = tree:FindFirstChild("Trunk") or tree.PrimaryPart
            if trunk then
                local dist = (trunk.Position - hrp.Position).Magnitude
                if dist <= auraRadius and dist < nearestDist then
                    nearestDist = dist
                    nearestTree = trunk
                end
            end
        end

        if nearestTree then
            -- ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞ 70 ‚Üí ‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ
            hrp.CFrame = CFrame.new(nearestTree.Position + Vector3.new(3,0,0))
        else
            -- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞ ‚Üí ‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏´‡∏≤‡πÑ‡∏°‡πâ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            local tree = trees[math.random(1, #trees)]
            local trunk = tree:FindFirstChild("Trunk") or tree.PrimaryPart
            if trunk then
                hrp.CFrame = CFrame.new(trunk.Position + Vector3.new(3,0,0))
            end
        end

        task.wait(0.5)
    end
end

-- ===========================================
-- UI: Sections & Toggles
-- ===========================================
Tabs.Auto:Section({ Title = "‡∏≠‡∏≠‡∏£‡πà‡∏≤", Icon = "star" })

-- Toggle ‡∏ï‡∏±‡∏î‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß
Tabs.Auto:Toggle({
    Title = "‡∏ï‡∏±‡∏î‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß",
    Value = false,
    Callback = function(state)
        chopAuraToggle = state
        if state then
            task.spawn(chopAuraLoop)
        else
            -- ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å task ‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
            for _, t in pairs(choppingTasks) do
                if t then task.cancel(t) end
            end
            choppingTasks = {}

            local tool, _ = getAnyToolWithDamageID(true)
            unequipTool(tool)
            removeAllTreeHighlights() -- ‡∏•‡∏ö Highlight ‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        end
    end
})

Tabs.Auto:Toggle({
    Title = "‡∏≠‡∏≠‡πÇ‡∏ï‡πâ‡∏ß‡∏≤‡∏õ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏π‡πà‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏î‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß",
    Default = false,
    Callback = function(state)
        autoChopToggle = state
        if state then
            task.spawn(warpcop)
        end
    end
})

Tabs.Auto:Toggle({
    Title = "‡∏Ü‡πà‡∏≤‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß",
    Value = false,
    Callback = function(state)
        killAuraToggle = state
        if state then
            task.spawn(killAuraLoop)
        else
            local tool, _ = getAnyToolWithDamageID(false)
            unequipTool(tool)
        end
    end
})



Tabs.Auto:Section({ Title = "‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥", Icon = "flame" })

local selectedCampfireItems = {}
local autoUpgradeCampfireEnabled = false

Tabs.Auto:Dropdown({
    Title = "‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î",
    Values = campfireFuelItems,
    Multi = true, -- ‚úÖ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
    AllowNone = true,
    Callback = function(options)
        selectedCampfireItems = options
    end
})

Tabs.Auto:Toggle({
    Title = "‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Value = false,
    Callback = function(checked)
        autoUpgradeCampfireEnabled = checked
        if checked then
            task.spawn(function()
                while autoUpgradeCampfireEnabled do
                    if #selectedCampfireItems > 0 then
                        for _, itemName in ipairs(selectedCampfireItems) do
                            for _, item in ipairs(workspace:WaitForChild("Items"):GetChildren()) do
                                if item.Name == itemName then
                                    moveItemToPos(item, campfireDropPos)
                                end
                            end
                        end
                    end
                    task.wait(2)
                end
            end)
        end
    end
})

-- ==============================
-- ‚öôÔ∏è ‡∏™‡∏•‡∏≤‡∏¢‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
-- ==============================
Tabs.Auto:Section({ Title = "‡∏™‡∏•‡∏≤‡∏¢‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥", Icon = "cog" })

local selectedScrapItems = {}
local autoScrapItemsEnabled = false

Tabs.Auto:Dropdown({
    Title = "‡∏™‡∏•‡∏≤‡∏¢‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ç‡∏¢‡∏∞",
    Values = scrapjunkItems,
    Multi = true, -- ‚úÖ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
    AllowNone = true,
    Callback = function(options)
        selectedScrapItems = options
    end
})

Tabs.Auto:Toggle({
    Title = "‡∏™‡∏•‡∏≤‡∏¢‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Value = false,
    Callback = function(checked)
        autoScrapItemsEnabled = checked
        if checked then
            task.spawn(function()
                while autoScrapItemsEnabled do
                    if #selectedScrapItems > 0 then
                        for _, itemName in ipairs(selectedScrapItems) do
                            for _, item in ipairs(workspace:WaitForChild("Items"):GetChildren()) do
                                if item.Name == itemName then
                                    moveItemToPos(item, autoScrapPos)
                                end
                            end
                        end
                    end
                    task.wait(2)
                end
            end)
        end
    end
})

Tabs.Auto:Section({ Title = "‡∏ó‡∏≥‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥", Icon = "flame" })

Tabs.Auto:Dropdown({
    Title = "‡∏ó‡∏≥‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Values = autocookItems,
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        for _, itemName in ipairs(autocookItems) do
            autoCookEnabledItems[itemName] = table.find(options, itemName) ~= nil
        end
    end
})

Tabs.Auto:Toggle({
    Title = "‡∏ó‡∏≥‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Value = false,
    Callback = function(state)
        autoCookEnabled = state
    end
})

coroutine.wrap(function()
    while true do
        if autoCookEnabled then
            for itemName, enabled in pairs(autoCookEnabledItems) do
                if enabled then
                    for _, item in ipairs(Workspace:WaitForChild("Items"):GetChildren()) do
                        if item.Name == itemName then
                            moveItemToPos(item, campfireDropPos)
                        end
                    end
                end
            end
        end
        task.wait(0.5)
    end
end)()




Tabs.Tp:Section({ Title = "‡∏ß‡∏≤‡∏õ", Icon = "map" })

Tabs.Tp:Button({
    Title = "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏Å‡∏≠‡∏á‡πÑ‡∏ü",
    Locked = false,
    Callback = function()
        tp1()
    end
})

Tabs.Tp:Button({
    Title = "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏£‡∏≤‡∏Å‡∏≤‡∏£",
    Locked = false,
    Callback = function()
        tp2()
    end
})

Tabs.Tp:Button({
    Title = "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡πÇ‡∏ã‡∏ô‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢",
    Callback = function()
        if not workspace:FindFirstChild("SafeZonePart") then
            local createpart = Instance.new("Part")
            createpart.Name = "SafeZonePart"
            createpart.Size = Vector3.new(30, 3, 30)
            createpart.Position = Vector3.new(0, 350, 0)
            createpart.Anchored = true
            createpart.CanCollide = true
            createpart.Transparency = 0.8
            createpart.Color = Color3.fromRGB(255, 0, 0)
            createpart.Parent = workspace
        end
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        hrp.CFrame = CFrame.new(0, 360, 0)
    end
})



Tabs.Tp:Section({ Title = "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ", Icon = "tree-deciduous" })

Tabs.Tp:Button({
    Title = "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏™‡∏∏‡πà‡∏°",
    Callback = function()
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart", 3)
        if not hrp then return end

        local map = workspace:FindFirstChild("Map")
        if not map then return end

        local foliage = map:FindFirstChild("Foliage") or map:FindFirstChild("Landmarks")
        if not foliage then return end

        local trees = {}
        for _, obj in ipairs(foliage:GetChildren()) do
            if obj.Name == "Small Tree" and obj:IsA("Model") then
                local trunk = obj:FindFirstChild("Trunk") or obj.PrimaryPart
                if trunk then
                    table.insert(trees, trunk)
                end
            end
        end

        if #trees > 0 then
            local trunk = trees[math.random(1, #trees)]
            local treeCFrame = trunk.CFrame
            local rightVector = treeCFrame.RightVector
            local targetPosition = treeCFrame.Position + rightVector * 3
            hrp.CFrame = CFrame.new(targetPosition)
        end
    end
})

Tabs.Tp:Section({ Title = "‡πÄ‡∏î‡πá‡∏Å", Icon = "eye" })

local MobDropdown = Tabs.Tp:Dropdown({
    Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡πá‡∏Å",
    Values = currentMobNames,
    Multi = false,
    AllowNone = true,
    Callback = function(options)
        selectedMob = options[#options] or currentMobNames[1] or nil
    end
})

Tabs.Tp:Button({
    Title = "‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£",
    Locked = false,
    Callback = function()
        currentMobs, currentMobNames = getMobs()
        if #currentMobNames > 0 then
            selectedMob = currentMobNames[1]
            MobDropdown:Refresh(currentMobNames)
        else
            selectedMob = nil
            MobDropdown:Refresh({ "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏î‡πá‡∏Å" })
        end
    end
})

Tabs.Tp:Button({
    Title = "‡∏ß‡∏≤‡∏õ‡πÑ‡∏õ‡πÄ‡∏î‡πá‡∏Å",
    Locked = false,
    Callback = function()
        if selectedMob and currentMobs then
            for i, name in ipairs(currentMobNames) do
                if name == selectedMob then
                    local targetMob = currentMobs[i]
                    if targetMob then
                        local part = targetMob.PrimaryPart or targetMob:FindFirstChildWhichIsA("BasePart")
                        if part and game.Players.LocalPlayer.Character then
                            local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                hrp.CFrame = part.CFrame + Vector3.new(0, 5, 0)
                            end
                        end
                    end
                    break
                end
            end
        end
    end
})

Tabs.Tp:Section({ Title = "‡∏´‡∏µ‡∏ö", Icon = "box" })

local AutoChestToggle = Tabs.Tp:Toggle({
    Title = "‡∏≠‡∏≠‡πÇ‡∏ï‡πâ‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏µ‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
    Locked = false,
    Value = false,
    Callback = function(v)
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

        if not _G.AutoChestData then
            _G.AutoChestData = {
                running = false,
                opened = {}, -- ‡∏à‡∏≥‡∏´‡∏µ‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß
                originalCFrame = nil
            }
        end

        local function getChests()
            local chests = {}
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and string.find(obj.Name, "Item Chest") then
                    -- ‡∏Ç‡πâ‡∏≤‡∏°‡∏´‡∏µ‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
                    if not _G.AutoChestData.opened[obj] then
                        table.insert(chests, obj)
                    end
                end
            end
            return chests
        end

        local function getPrompt(model)
            local prompts = {}
            for _, obj in ipairs(model:GetDescendants()) do
                if obj:IsA("ProximityPrompt") then
                    table.insert(prompts, obj)
                end
            end
            return prompts
        end

        if v then
            if _G.AutoChestData.running then return end
            _G.AutoChestData.running = true
            _G.AutoChestData.originalCFrame = humanoidRootPart.CFrame
            task.spawn(function()
                while _G.AutoChestData.running do
                    local chests = getChests()
                    if #chests == 0 then
                        _G.AutoChestData.running = false
                        break
                    end

                    for _, chest in ipairs(chests) do
                        if not _G.AutoChestData.running then break end

                        local part = chest.PrimaryPart or chest:FindFirstChildWhichIsA("BasePart")
                        if part then
                            humanoidRootPart.CFrame = part.CFrame + Vector3.new(0, 6, 0)

                            local prompts = getPrompt(chest)
                            for _, prompt in ipairs(prompts) do
                                fireproximityprompt(prompt, math.huge)
                            end

                            _G.AutoChestData.opened[chest] = true -- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß

                            task.wait(0.50) -- ‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏¥‡∏î
                        end
                    end
                    task.wait(0.1)
                end

                -- ‡∏Å‡∏•‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏£‡πá‡∏à
                if _G.AutoChestData.originalCFrame then
                    humanoidRootPart.CFrame = _G.AutoChestData.originalCFrame
                end
            end)
        else
            _G.AutoChestData.running = false
            if _G.AutoChestData.originalCFrame then
                humanoidRootPart.CFrame = _G.AutoChestData.originalCFrame
            end
        end
    end
})





-- ==========================================
-- üõ†Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡∏∂‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡∏¥‡πâ‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ä‡∏ô‡∏Å‡∏±‡∏ô (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß)
-- ==========================================
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local player = Players.LocalPlayer

-- ==========================================
-- ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
-- ==========================================
local campfirePos = Vector3.new(0.8, 11.7, 0.5) 	 -- ‡πÄ‡∏û‡∏¥‡πà‡∏° Y +2 ‡πÉ‡∏´‡πâ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏Å‡∏≠‡∏á‡πÑ‡∏ü‡πÄ‡∏î‡∏¥‡∏°
local craftTablePos = Vector3.new(21.2, 8.1, -5.5) 	-- ‡πÄ‡∏û‡∏¥‡πà‡∏° Y +2 ‡πÉ‡∏´‡πâ‡∏™‡∏π‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏î‡∏¥‡∏°

-- ==========================================
-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ô Dropdown ‡πÅ‡∏ö‡∏ö '‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß'
-- *‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤ (‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ)
-- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô nil ‡πÉ‡∏ô‡∏ï‡∏≠‡∏ô‡πÅ‡∏£‡∏Å ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î error ‡πÑ‡∏î‡πâ
-- ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤ ({}):
-- local junkItems = {} -- ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏à‡∏£‡∏¥‡∏á‡∏≠‡∏¢‡∏π‡πà
-- local fuelItems = {}
-- local foodItems = {}
-- local medicalItems = {}
-- local equipmentItems = {}

local selectedJunkItems = {}
local selectedFuelItems = {}
local selectedFoodItems = {}
local selectedMedicalItems = {}
local selectedEquipmentItems = {}
-- ==========================================
-- Dropdown ‡∏ö‡∏ô‡∏™‡∏∏‡∏î: ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏´‡∏°‡∏ß‡∏î
-- ==========================================
local selectedTarget = "Campfire" -- ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô

Tabs.br:Dropdown({
	Title = "‡∏î‡∏∂‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà",
	Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏´‡∏°‡∏ß‡∏î: Player / Campfire / Scrap",
	Values = { "Player", "Campfire", "Scrap" },
	Multi = false,
	AllowNone = false,
	Callback = function(option)
		selectedTarget = option
	end
})

-- ==========================================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
-- ==========================================
local function getTargetCFrame()
	local char = player.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return CFrame.new(Vector3.new(0,5,0)) end

	if selectedTarget == "Player" then
		return CFrame.new(hrp.Position + Vector3.new(0,5,0))
	elseif selectedTarget == "Campfire" then
		return CFrame.new(campfirePos)
	elseif selectedTarget == "Scrap" then
		return CFrame.new(craftTablePos)
	end

	return CFrame.new(hrp.Position + Vector3.new(0,5,0))
end

-- ==========================================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏´‡∏≤ root ‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏≤‡∏£‡πå‡∏ó
-- ==========================================
local function getRootObject(obj)
	if obj:IsA("BasePart") and obj.Parent and obj.Parent:IsA("Model") then
		return obj.Parent
	end
	if obj:IsA("Model") then return obj end
	if obj:IsA("BasePart") then return obj end
	return nil
end

-- ==========================================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏¢‡πâ‡∏≤‡∏¢‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏≤‡∏£‡πå‡∏ó‡πÑ‡∏õ‡∏¢‡∏±‡∏á CFrame
-- ==========================================
local function moveModelToCFrame(root, targetCFrame)
	if root:IsA("Model") then
		local prim = root.PrimaryPart or root:FindFirstChildWhichIsA("BasePart")
		if prim then
			if root.PrimaryPart then
				pcall(function() root:SetPrimaryPartCFrame(targetCFrame) end)
			else
				local offset = targetCFrame.Position - prim.Position
				for _, p in ipairs(root:GetDescendants()) do
					if p:IsA("BasePart") then
						p.CFrame = p.CFrame + offset
					end
				end
			end
		end
	elseif root:IsA("BasePart") then
		pcall(function() root.CFrame = targetCFrame end)
	end
end

-- ==========================================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡∏¥‡πâ‡∏ô ‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏î‡∏∂‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ
-- *‡∏ñ‡∏π‡∏Å‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö '‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß'
-- *‡∏•‡∏ö stopFlag ‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ß‡∏ô‡∏•‡∏π‡∏õ
-- ==========================================
local isCollecting = false -- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ô‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏£‡∏±‡∏ß‡πÜ

local function bypassBringSystem(items)
	if isCollecting then return end -- ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ã‡πâ‡∏≥
	isCollecting = true

	local char = player.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then
		isCollecting = false
		return
	end

	local searchContainers = {}
	if Workspace:FindFirstChild("Items") then
		table.insert(searchContainers, Workspace.Items)
	end
	table.insert(searchContainers, Workspace)
    
    local itemsFoundAndMoved = 0 -- ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ó‡∏µ‡πà‡∏î‡∏∂‡∏á‡πÑ‡∏î‡πâ

	for _, itemName in ipairs(items) do
		local seenRoots = {}

		-- ‡∏•‡∏π‡∏õ‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ß‡∏ô‡∏´‡∏≤‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á itemName ‡∏ó‡∏µ‡πà‡∏û‡∏ö‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏´‡∏°‡∏î
		while true do
			local itemFoundInIteration = false -- ‡πÉ‡∏ä‡πâ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ‡∏î‡∏∂‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            
			for _, container in ipairs(searchContainers) do
				for _, obj in ipairs(container:GetDescendants()) do
                    
                    -- ‡πÉ‡∏ä‡πâ obj:IsA("BasePart") ‡∏´‡∏£‡∏∑‡∏≠ obj:IsA("Model") ‡∏Å‡πà‡∏≠‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
                    if not (obj:IsA("BasePart") or obj:IsA("Model")) then continue end

					local root = getRootObject(obj)
					if not root then continue end
					if root:IsDescendantOf(char) then continue end
					if root.Name ~= itemName then continue end
                    
                    -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏Ñ‡∏¢‡∏ñ‡∏π‡∏Å‡∏î‡∏∂‡∏á‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏£‡∏≠‡∏ö‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô)
                    if seenRoots[root] then continue end
                    seenRoots[root] = true 
                    
                    itemFoundInIteration = true -- ‡∏û‡∏ö‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏∂‡∏á‡πÅ‡∏•‡πâ‡∏ß
                    itemsFoundAndMoved = itemsFoundAndMoved + 1

					-- ‡∏î‡∏∂‡∏á‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡∏¥‡πâ‡∏ô
					local targetCFrame = getTargetCFrame()

					-- Anchored
					for _, p in ipairs(root:GetDescendants()) do
						if p:IsA("BasePart") then
							p.Anchored = true
						end
					end

					-- Move
					moveModelToCFrame(root, targetCFrame)
					task.wait(0.01)

					-- ‡∏õ‡∏•‡πà‡∏≠‡∏¢
					for _, p in ipairs(root:GetDescendants()) do
						if p:IsA("BasePart") then
							p.Anchored = false
							p.Velocity = Vector3.new(0, -6, 0)
						end
					end

					-- ‡∏£‡∏≠‡∏Ç‡∏≠‡∏á‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡πà‡∏≠‡∏¢‡∏î‡∏∂‡∏á‡∏ä‡∏¥‡πâ‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ
					task.wait(0.10)
                    
                    -- **‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏±‡∏ç‡∏´‡∏≤ GOTO:**
                    -- ‡πÉ‡∏ä‡πâ 'break' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÉ‡∏ô‡∏•‡∏π‡∏õ 'for _, obj...' 
                    -- ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡πÑ‡∏î‡πâ 1 ‡∏ä‡∏¥‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß
                    -- ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô ‡∏•‡∏π‡∏õ 'while true' ‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ã‡πâ‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ä‡∏¥‡πâ‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                    break 
				end
                
                -- ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£ break ‡∏à‡∏≤‡∏Å‡∏•‡∏π‡∏õ‡∏î‡πâ‡∏≤‡∏ô‡πÉ‡∏ô‡∏™‡∏∏‡∏î (‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏î‡∏∂‡∏á‡∏Ç‡∏≠‡∏á‡πÑ‡∏î‡πâ 1 ‡∏ä‡∏¥‡πâ‡∏ô) ‡πÉ‡∏´‡πâ‡∏≠‡∏≠‡∏Å‡∏•‡∏π‡∏õ container ‡∏î‡πâ‡∏ß‡∏¢
                if itemFoundInIteration then
                    break
                end
			end

			-- ‡∏ñ‡πâ‡∏≤‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏° itemName ‡∏≠‡∏µ‡∏Å‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏¥‡∏Å‡∏î‡∏∂‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ô‡∏µ‡πâ
			if not itemFoundInIteration then
				break
			end
            
            -- ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡πÑ‡∏≠‡πÄ‡∏ó‡∏° ‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏•‡∏π‡∏õ 'while true' ‡πÅ‡∏•‡∏∞‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏±‡πâ‡∏ô‡πÜ ‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏¥‡∏°‡∏ä‡∏¥‡πâ‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
            task.wait(0.01) 
		end
	end
    
    -- ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô
	isCollecting = false
end

-- ==========================================
-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏°‡∏ß‡∏î (‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô '‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß')
-- ==========================================
-- *‡∏•‡∏ö setupCategoryUI ‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ Toggle ‡∏≠‡∏≠‡∏Å
-- *‡∏ô‡∏≥‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á Dropdown ‡πÅ‡∏•‡∏∞ Button ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏°‡∏ß‡∏î‡∏°‡∏≤‡∏ï‡πà‡∏≠‡∏ó‡πâ‡∏≤‡∏¢‡πÅ‡∏ó‡∏ô

-- ===================================================
-- üß© ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö Tabs.br (UI ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏°‡∏ß‡∏î) ‡πÅ‡∏ö‡∏ö‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
-- ===================================================

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å bypassBringSystem ‡πÅ‡∏Ñ‡πà‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)
local function pullItemsOnce(itemList)
	if isCollecting then return end -- ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô
    
    -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if itemList and #itemList > 0 then
        -- ‡πÉ‡∏ä‡πâ task.spawn ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå UI ‡∏´‡∏•‡∏±‡∏Å‡πÑ‡∏°‡πà‡∏Ñ‡πâ‡∏≤‡∏á‡∏Ç‡∏ì‡∏∞‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡∏≠‡∏á
        task.spawn(function()
            bypassBringSystem(itemList)
        end)
    -- else
        -- print("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏î‡∏∂‡∏á")
    end
end

-- ==============================
-- üí† ‡πÄ‡∏®‡∏©‡πÄ‡∏´‡∏•‡πá‡∏Å
-- ==============================
Tabs.br:Section({ Title = "‡πÄ‡∏®‡∏©‡πÄ‡∏´‡∏•‡πá‡∏Å", Icon = "box" })

Tabs.br:Dropdown({
	Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏®‡∏©‡πÄ‡∏´‡∏•‡πá‡∏Å",
	Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
	Values = junkItems, -- ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ junkItems ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	Multi = true,
	AllowNone = true,
	Callback = function(options)
		selectedJunkItems = options
	end
})

Tabs.br:Button({
	Title = "‡∏î‡∏∂‡∏á‡πÄ‡∏®‡∏©‡πÄ‡∏´‡∏•‡πá‡∏Å (‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)",
	Callback = function()
		pullItemsOnce(selectedJunkItems)
	end
})

-- ==============================
-- üî• ‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏¥‡∏á
-- ==============================
Tabs.br:Section({ Title = "‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏¥‡∏á", Icon = "flame" })

Tabs.br:Dropdown({
	Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏¥‡∏á",
	Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
	Values = fuelItems, -- ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ fuelItems ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	Multi = true,
	AllowNone = true,
	Callback = function(options)
		selectedFuelItems = options
	end
})

Tabs.br:Button({
	Title = "‡∏î‡∏∂‡∏á‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡πÄ‡∏û‡∏•‡∏¥‡∏á (‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)",
	Callback = function()
		pullItemsOnce(selectedFuelItems)
	end
})

-- ==============================
-- üç¥ ‡∏≠‡∏≤‡∏´‡∏≤‡∏£
-- ==============================
Tabs.br:Section({ Title = "‡∏≠‡∏≤‡∏´‡∏≤‡∏£", Icon = "utensils" })

Tabs.br:Dropdown({
	Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏≤‡∏´‡∏≤‡∏£",
	Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
	Values = foodItems, -- ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ foodItems ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	Multi = true,
	AllowNone = true,
	Callback = function(options)
		selectedFoodItems = options
	end
})

Tabs.br:Button({
	Title = "‡∏î‡∏∂‡∏á‡∏≠‡∏≤‡∏´‡∏≤‡∏£ (‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)",
	Callback = function()
		pullItemsOnce(selectedFoodItems)
	end
})

-- ==============================
-- üíä ‡∏¢‡∏≤
-- ==============================
Tabs.br:Section({ Title = "‡∏¢‡∏≤", Icon = "bandage" })

Tabs.br:Dropdown({
	Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡∏≤‡∏£‡∏±‡∏Å‡∏©‡∏≤",
	Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
	Values = medicalItems, -- ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ medicalItems ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	Multi = true,
	AllowNone = true,
	Callback = function(options)
		selectedMedicalItems = options
	end
})

Tabs.br:Button({
	Title = "‡∏î‡∏∂‡∏á‡∏¢‡∏≤ (‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)",
	Callback = function()
		pullItemsOnce(selectedMedicalItems)
	end
})

-- ==============================
-- ‚öîÔ∏è ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
-- ==============================
Tabs.br:Section({ Title = "‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå", Icon = "sword" })

Tabs.br:Dropdown({
	Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå",
	Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
	Values = equipmentItems, -- ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ equipmentItems ‡∏ñ‡∏π‡∏Å‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	Multi = true,
	AllowNone = true,
	Callback = function(options)
		selectedEquipmentItems = options
	end
})

Tabs.br:Button({
	Title = "‡∏î‡∏∂‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå (‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)",
	Callback = function()
		pullItemsOnce(selectedEquipmentItems)
	end
})



Tabs.Fly:Section({ Title = "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô", Icon = "user" })

-- üõ°Ô∏è ‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏°‡∏ï‡∏∞
local rs = game:GetService("ReplicatedStorage")
local dmgEvent = rs:FindFirstChild("RemoteEvents") and rs.RemoteEvents:FindFirstChild("DamagePlayer")
local godModeConnection

Tabs.Fly:Toggle({
    Title = "‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏°‡∏ï‡∏∞ (God Mode)",
    Value = false,
    Callback = function(state)
        if state then
            if dmgEvent then
                godModeConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    pcall(function()
                        dmgEvent:FireServer(-math.huge)
                    end)
                end)
            end
        else
            if godModeConnection then
                godModeConnection:Disconnect()
                godModeConnection = nil
            end
        end
    end
})

Tabs.Fly:Slider({
    Title = "Fly Speed",
    Value = { Min = 1, Max = 20, Default = 1 },
    Callback = function(value)
        flySpeed = value
        if FLYING then
            task.spawn(function()
                while FLYING do
                    task.wait(0.1)
                    if game:GetService("UserInputService").TouchEnabled then
                        local root = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if root and root:FindFirstChild("BodyVelocity") then
                            local bv = root:FindFirstChild("BodyVelocity")
                            bv.Velocity = bv.Velocity.Unit * (flySpeed * 50) -- Adjust velocity magnitude
                        end
                    end
                end
            end)
        end
    end
})

Tabs.Fly:Toggle({
    Title = "Enable Fly",
    Value = false,
    Callback = function(state)
        flyToggle = state
        if flyToggle then
            if game:GetService("UserInputService").TouchEnabled then
                MobileFly()
            else
                sFLY()
            end
        else
            NOFLY()
            UnMobileFly()
        end
    end
})



-- ===================================================
-- üèÉüí® ‡∏™‡πà‡∏ß‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏ô (Walk Speed) ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß
-- ===================================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- ‚öôÔ∏è Global Variables (‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå)
local currentWalkSpeed = 16 -- ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
local walkSpeedToggle = false
local walkSpeedConnection = nil

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
local function setSpeed(val)
    local char = Players.LocalPlayer.Character
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    if humanoid then 
        humanoid.WalkSpeed = val 
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡πá‡∏≠‡∏Ñ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
local function lockSpeedLoop()
    -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ Humanoid ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    local char = Players.LocalPlayer.Character
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    
    if humanoid and humanoid.WalkSpeed ~= currentWalkSpeed then
        humanoid.WalkSpeed = currentWalkSpeed
    end
end

-- -------------------
-- üîΩ Slider ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
-- -------------------
Tabs.Fly:Slider({
    Title = "‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏ô",
    Value = { Min = 16, Max = 150, Default = 16 },
    Callback = function(value)
        currentWalkSpeed = value -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏±‡∏ô‡∏ó‡∏µ

        -- ‡∏ñ‡πâ‡∏≤ Toggle ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (Real-time update)
        if walkSpeedToggle then
            setSpeed(currentWalkSpeed) 
        end
    end
})

-- -------------------
-- üîò Toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏ô
-- -------------------
Tabs.Fly:Toggle({
    Title = "‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏ô",
    Value = false,
    Callback = function(state)
        walkSpeedToggle = state
        
        if state then
            -- 1. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î
            setSpeed(currentWalkSpeed) 

            -- 2. ‡πÄ‡∏£‡∏¥‡πà‡∏° Loop ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡πá‡∏≠‡∏Ñ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß (Real-time lock)
            walkSpeedConnection = RunService.Heartbeat:Connect(lockSpeedLoop)
            
            -- **Optional:** ‡∏´‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡∏ï‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏´‡∏°‡πà
            Players.LocalPlayer.CharacterAdded:Wait() 
            walkSpeedConnection = Players.LocalPlayer.CharacterAdded:Connect(function(char)
                if walkSpeedToggle then
                    char:FindFirstChildOfClass("Humanoid").WalkSpeed = currentWalkSpeed
                end
            end)

        else
            -- 1. ‡∏´‡∏¢‡∏∏‡∏î Loop
            if walkSpeedConnection then
                walkSpeedConnection:Disconnect()
                walkSpeedConnection = nil
            end
            
            -- 2. ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏î‡∏¥‡∏° (16)
            setSpeed(16)
        end
    end
})

local RunService = game:GetService("RunService")
local noclipConnection

Tabs.Fly:Toggle({
    Title = "‡∏ó‡∏∞‡∏•‡∏∏‡∏™‡∏¥‡πà‡∏á‡∏Ç‡∏≠‡∏á (Noclip)",
    Value = false,
    Callback = function(state)
        if state then
            noclipConnection = RunService.Stepped:Connect(function()
                local char = Players.LocalPlayer.Character
                if char then
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end
})

local UserInputService = game:GetService("UserInputService")
local infJumpConnection

Tabs.Fly:Toggle({
    Title = "‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î (Inf Jump)",
    Value = false,
    Callback = function(state)
        if state then
            infJumpConnection = UserInputService.JumpRequest:Connect(function()
                local char = Players.LocalPlayer.Character
                local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end)
        else
            if infJumpConnection then
                infJumpConnection:Disconnect()
                infJumpConnection = nil
            end
        end
    end
})

-- ESP
function createESPText(part, text, color)
    if part:FindFirstChild("ESPTexto") then return end

    local esp = Instance.new("BillboardGui")
    esp.Name = "ESPTexto"
    esp.Adornee = part
    esp.Size = UDim2.new(0, 100, 0, 20)
    esp.StudsOffset = Vector3.new(0, 2.5, 0)
    esp.AlwaysOnTop = true
    esp.MaxDistance = 300

    local label = Instance.new("TextLabel")
    label.Parent = esp
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = color or Color3.fromRGB(255,255,0)
    label.TextStrokeTransparency = 0.2
    label.TextScaled = true
    label.Font = Enum.Font.GothamBold

    esp.Parent = part
end

local function Aesp(name, type)
    local container
    local color
    if type == "item" then
        container = workspace:FindFirstChild("Items")
        color = Color3.fromRGB(0, 255, 0)
    elseif type == "mob" then
        container = workspace:FindFirstChild("Characters")
        color = Color3.fromRGB(255, 255, 0)
    else
        return
    end
    if not container then return end

    for _, obj in ipairs(container:GetChildren()) do
        if obj.Name == name then
            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                createESPText(part, obj.Name, color)
            end
        end
    end
end

local function Desp(name, type)
    local container
    if type == "item" then
        container = workspace:FindFirstChild("Items")
    elseif type == "mob" then
        container = workspace:FindFirstChild("Characters")
    else
        return
    end
    if not container then return end

    for _, obj in ipairs(container:GetChildren()) do
        if obj.Name == name then
            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                for _, gui in ipairs(part:GetChildren()) do
                    if gui:IsA("BillboardGui") and gui.Name == "ESPTexto" then
                        gui:Destroy()
                    end
                end
            end
        end
    end
end

local selectedItems = {}
local selectedMobs = {}
local espItemsEnabled = false
local espMobsEnabled = false
local espConnections = {}

Tabs.esp:Section({ Title = "ESP ‡∏Ç‡∏≠‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°", Icon = "package" })

Tabs.esp:Dropdown({
    Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏≠‡πÄ‡∏ó‡∏° ESP",
    Values = ie,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedItems = options
        if espItemsEnabled then
            for _, name in ipairs(ie) do
                if table.find(selectedItems, name) then
                    Aesp(name, "item")
                else
                    Desp(name, "item")
                end
            end
        else
            for _, name in ipairs(ie) do
                Desp(name, "item")
            end
        end
    end
})

Tabs.esp:Toggle({
    Title = "‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ESP ‡∏Ç‡∏≠‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°",
    Value = false,
    Callback = function(state)
        espItemsEnabled = state
        for _, name in ipairs(ie) do
            if state and table.find(selectedItems, name) then
                Aesp(name, "item")
            else
                Desp(name, "item")
            end
        end

        if state then
            if not espConnections["Items"] then
                local container = workspace:FindFirstChild("Items")
                if container then
                    espConnections["Items"] = container.ChildAdded:Connect(function(obj)
                        if table.find(selectedItems, obj.Name) then
                            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
                            if part then
                                createESP(part, obj.Name, Color3.fromRGB(0, 255, 0))
                            end
                        end
                    end)
                end
            end
        else
            if espConnections["Items"] then
                espConnections["Items"]:Disconnect()
                espConnections["Items"] = nil
            end
        end
    end
})

Tabs.esp:Section({ Title = "ESP ‡∏Ç‡∏≠‡∏á‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå", Icon = "user" })

Tabs.esp:Dropdown({
    Title = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå ESP",
    Values = me,
    Value = {},
    Multi = true,
    AllowNone = true,
    Callback = function(options)
        selectedMobs = options
        if espMobsEnabled then
            for _, name in ipairs(me) do
                if table.find(selectedMobs, name) then
                    Aesp(name, "mob")
                else
                    Desp(name, "mob")
                end
            end
        else
            for _, name in ipairs(me) do
                Desp(name, "mob")
            end
        end
    end
})

Tabs.esp:Toggle({
    Title = "‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î ESP ‡∏Ç‡∏≠‡∏á‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå",
    Value = false,
    Callback = function(state)
        espMobsEnabled = state
        for _, name in ipairs(me) do
            if state and table.find(selectedMobs, name) then
                Aesp(name, "mob")
            else
                Desp(name, "mob")
            end
        end

        if state then
            if not espConnections["Mobs"] then
                local container = workspace:FindFirstChild("Characters")
                if container then
                    espConnections["Mobs"] = container.ChildAdded:Connect(function(obj)
                        if table.find(selectedMobs, obj.Name) then
                            local part = obj:IsA("BasePart") and obj or obj:FindFirstChildWhichIsA("BasePart")
                            if part then
                                createESP(part, obj.Name, Color3.fromRGB(255, 255, 0))
                            end
                        end
                    end)
                end
            end
        else
            if espConnections["Mobs"] then
                espConnections["Mobs"]:Disconnect()
                espConnections["Mobs"] = nil
            end
        end
    end
})


Tabs.Anti:Section({ Title = "‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏°‡∏≠‡∏ô‡∏™‡πÄ‡∏ï‡∏≠‡∏£‡πå", Icon = "skull" })

-- ==============================
-- ‚ö° Spam Ram, Deer & Owl
-- ==============================
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Toggles
local spamRamToggle = false
local spamDeerToggle = false
local spamOwlToggle = false

-- Spam Ram
local ramLoop
Tabs.Anti:Toggle({
    Title = "‡∏™‡∏ï‡∏±‡πâ‡∏ô ‡πÅ‡∏û‡∏∞",
    Value = false,
    Callback = function(state)
        spamRamToggle = state
        if state then
            ramLoop = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local ram = Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild("Ram")
                    local remote = ReplicatedStorage:FindFirstChild("RemoteEvents") and ReplicatedStorage.RemoteEvents:FindFirstChild("MonsterHitByTorch")
                    if ram and remote then
                        remote:InvokeServer(ram)
                    end
                end)
                task.wait(0.0001)
            end)
        else
            if ramLoop then
                ramLoop:Disconnect()
                ramLoop = nil
            end
        end
    end
})

-- Spam Deer
local deerLoop
Tabs.Anti:Toggle({
    Title = "‡∏™‡∏ï‡∏±‡πâ‡∏ô ‡∏Å‡∏ß‡∏≤‡∏á",
    Value = false,
    Callback = function(state)
        spamDeerToggle = state
        if state then
            deerLoop = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local deer = Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild("Deer")
                    local remote = ReplicatedStorage:FindFirstChild("RemoteEvents") and ReplicatedStorage.RemoteEvents:FindFirstChild("MonsterHitByTorch")
                    if deer and remote then
                        remote:InvokeServer(deer)
                    end
                end)
                task.wait(0.0001)
            end)
        else
            if deerLoop then
                deerLoop:Disconnect()
                deerLoop = nil
            end
        end
    end
})

-- Spam Owl
local owlLoop
Tabs.Anti:Toggle({
    Title = "‡∏™‡∏ï‡∏±‡πâ‡∏ô ‡∏ô‡∏Å‡∏Æ‡∏π‡∏Å",
    Value = false,
    Callback = function(state)
        spamOwlToggle = state
        if state then
            owlLoop = RunService.RenderStepped:Connect(function()
                pcall(function()
                    local owl = Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild("Owl")
                    local remote = ReplicatedStorage:FindFirstChild("RemoteEvents") and ReplicatedStorage.RemoteEvents:FindFirstChild("MonsterHitByTorch")
                    if owl and remote then
                        remote:InvokeServer(owl)
                    end
                end)
                task.wait(0.0001)
            end)
        else
            if owlLoop then
                owlLoop:Disconnect()
                owlLoop = nil
            end
        end
    end
})



local Lighting = game:GetService("Lighting")

Tabs.Vision:Section({ Title = "‡∏Å‡∏≤‡∏£‡∏°‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏ô", Icon = "eye" })

-- ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤ Lighting ‡πÄ‡∏î‡∏¥‡∏°
local originalLightingValues = {
	Brightness = Lighting.Brightness,
	Ambient = Lighting.Ambient,
	OutdoorAmbient = Lighting.OutdoorAmbient,
	ShadowSoftness = Lighting.ShadowSoftness,
	GlobalShadows = Lighting.GlobalShadows,
	Technology = Lighting.Technology,
	ClockTime = Lighting.ClockTime,
	FogStart = Lighting.FogStart,
	FogEnd = Lighting.FogEnd,
	ColorShift_Top = Lighting.ColorShift_Top,
	ColorShift_Bottom = Lighting.ColorShift_Bottom
}

-- ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏•‡πá‡∏≠‡∏Ñ
local lockedValues = {}
local connections = {}

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏•‡πá‡∏≠‡∏Ñ
local function lockLightingProperty(propName, value)
	lockedValues[propName] = value
	if connections[propName] then connections[propName]:Disconnect() end
	connections[propName] = Lighting:GetPropertyChangedSignal(propName):Connect(function()
		if Lighting[propName] ~= value then
			Lighting[propName] = value
		end
	end)
	Lighting[propName] = value
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ
local function unlockLightingProperty(propName)
	if connections[propName] then
		connections[propName]:Disconnect()
		connections[propName] = nil
	end
	if originalLightingValues[propName] then
		Lighting[propName] = originalLightingValues[propName]
	end
	lockedValues[propName] = nil
end

------------------------------------------------
-- üîÜ ‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà
------------------------------------------------
Tabs.Vision:Toggle({
	Title = "‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏µ‡πà",
	Value = false,
	Callback = function(state)
		if state then
			lockLightingProperty("ClockTime", 14)
			lockLightingProperty("Brightness", 2.2)
			lockLightingProperty("Ambient", Color3.new(1,1,1))
			lockLightingProperty("OutdoorAmbient", Color3.new(1,1,1))
			lockLightingProperty("ShadowSoftness", 0)
			lockLightingProperty("GlobalShadows", false)
			lockLightingProperty("Technology", Enum.Technology.Compatibility)
		else
			for _, prop in ipairs({"ClockTime","Brightness","Ambient","OutdoorAmbient","ShadowSoftness","GlobalShadows","Technology"}) do
				unlockLightingProperty(prop)
			end
		end
	end
})

------------------------------------------------
-- üå´ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏´‡∏°‡∏≠‡∏Å
------------------------------------------------
Tabs.Vision:Toggle({
	Title = "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏´‡∏°‡∏≠‡∏Å",
	Value = false,
	Callback = function(state)
		if state then
			lockLightingProperty("FogStart", 99999)
			lockLightingProperty("FogEnd", 100000)
		else
			unlockLightingProperty("FogStart")
			unlockLightingProperty("FogEnd")
		end
	end
})

------------------------------------------------
-- üé® ‡∏™‡∏µ‡∏™‡∏±‡∏ô‡∏™‡∏î‡πÉ‡∏™
------------------------------------------------
Tabs.Vision:Toggle({
	Title = "‡∏™‡∏µ‡∏™‡∏±‡∏ô‡∏™‡∏î‡πÉ‡∏™",
	Value = false,
	Callback = function(state)
		if state then
			lockLightingProperty("ClockTime", 14)
			lockLightingProperty("GlobalShadows", false)
			lockLightingProperty("Ambient", Color3.fromRGB(180,180,180))
			lockLightingProperty("OutdoorAmbient", Color3.fromRGB(170,170,170))
			lockLightingProperty("ColorShift_Top", Color3.fromRGB(255,230,200))
			lockLightingProperty("ColorShift_Bottom", Color3.fromRGB(200,240,255))
		else
			for _, prop in ipairs({"ClockTime","GlobalShadows","Ambient","OutdoorAmbient","ColorShift_Top","ColorShift_Bottom"}) do
				unlockLightingProperty(prop)
			end
		end
	end
})

------------------------------------------------
-- ‚öôÔ∏è Boost FPS
------------------------------------------------
local originalMaterials = {}
local originalShadows = {}
local boosted = false

Tabs.Vision:Toggle({
	Title = "Boost FPS",
	Value = false,
	Callback = function(state)
		if state then
			boosted = true
			for _, obj in ipairs(workspace:GetDescendants()) do
				if obj:IsA("BasePart") then
					if not originalMaterials[obj] then
						originalMaterials[obj] = obj.Material
						originalShadows[obj] = obj.CastShadow
					end
					obj.Material = Enum.Material.SmoothPlastic
					obj.CastShadow = false
				end
			end
			lockLightingProperty("GlobalShadows", false)
		else
			boosted = false
			for obj, mat in pairs(originalMaterials) do
				if obj and obj:IsA("BasePart") then
					obj.Material = mat
					obj.CastShadow = originalShadows[obj]
				end
			end
			unlockLightingProperty("GlobalShadows")
		end
	end
})







Info = Tabs["Info"]

Info:Divider()

-- üåü ‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏±‡∏Å
Info:Section({  
    Title = "Dual Hub",
    TextXAlignment = "Center",
    TextSize = 50,
})

-- üí¨ ‡∏ú‡∏π‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á
Info:Section({  
    Title = "@Chx | @Kira",
    TextXAlignment = "Center",
    TextSize = 15,
})

Info:Divider()

-- üåê Discord + ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å
local Discord = Info:Paragraph({
    Title = "Discord",
    Desc = "‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏° Discord ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°!",
    Image = "",
    ImageSize = 0,
    Locked = false,
    TextXAlignment = "Center",
    Buttons = {
        {
            Title = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå",
            Callback = function()
                setclipboard("https://discord.gg/JtMCHtxRVb")
                WindUI:Notify({
                    Title = "üìã ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
                    Content = "‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå Discord ‡πÅ‡∏•‡πâ‡∏ß!",
                    Duration = 2
                })
            end,
        }
    }
})
